# 4.1 mysql 아키텍쳐

![image.png](4%201%20mysql%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A7%2023bc68478a0a806e832bdaa463ce23cc/image.png)

mysql  = mysql engine + storage engine 
mysql enigne : 클라이언트(프로그래밍 언어단) 요청 처리 커넥션 핸들러와 sql 파서 및 전처리기, 쿼리 최적화를 위한 옵티마이저

storage engine : 실데 데이터 디스크에 저장하는 역할, 여러 개 가능

```sql
mysql> CREATE TABLE test_table fd1 INT, fd2 INT ENGINE=INNODB;
```

test_Table InnoDB 스토리지 엔진을 사용

핸들러 API : mysql engine과 storag engine 연결

```sql
mysql> SHOW GLOBAL STATUS LIKE 'Handler%';
```

핸들러 API를 통해 얼마나 많은 데이터(레코드) 작업이 있었는지 확인

## **mysql 스레딩 구조**

![image.png](4%201%20mysql%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A7%2023bc68478a0a806e832bdaa463ce23cc/image%201.png)

mysql 서버는 프로세스 기반이 아닌 스레드 기반, 크게 포그라운드 스레드와 백그라운드 스레드로 나뉨

포그라운드 스레드 : 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재, 쿼리 문장 처리
클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 스레드 캐시로 돌아감.
스레드 캐시 용량 꽉 차면 종료시킴

포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시로부터 가져오며, 버퍼나 캐시에 없는 경
우에는 직접 디스크의 데이터나 인덱스 파일로부터 데이터를 읽어와서 작업을 처리한다.

백 그라운드 스레드 : 

InnoDB는 다음과 같이 여러 가지 작업이 백그라운드로 처리된다.

인서트 버퍼(Insert Buffer)를 병합하는 스레드
로그를 디스크로 기록하는 스레드
InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
데이터를 버퍼로 읽어 오는 스레드
잠금이나 데드락을 모니터링하는 스레드

가장 중요한 것은 로그 스레드와 쓰기 쓰레드.

데이터 쓰기는  지연(버퍼링) 되어 처리 가능, 하지만 읽기는 절대 지연 불가. INNODB는 데이트 쓰기 버퍼링, 그래서 끝까지 기달리지 않아도 됨. 하지만 MyISAM에서 일반적인 쿼리는 버퍼링 기능 사용 불가

![image.png](4%201%20mysql%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A7%2023bc68478a0a806e832bdaa463ce23cc/image%202.png)

운영체제가 실제로 얼마나 주고 하는 지 복잡해서 알 필요 X

그냥 단순하게 MySQL의 시스템 변수로 설정해 둔 만큼 운영체제로부터 메모리를 할당받는다고 생각해도 된다.

글로벌 메모리 영역과 로컬 메모리 영역은 MySQL 서버 내에 존재하는 많은 스레드가 공유해서 사용
하는 공간인지 여부에 따라 구분

글로벌 메모리 영역 : 모든 스레드에 의해 공유됨.
대표적인 예시 : 사진에 나옴

로컬 메모리 영역 : 클라이언스 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역, 클라이언트와 Mysql 서버와의 커넥션을 세션이라고 하기 때문에 세션 메모리 영역이라고도 표현

로컬 메모리는 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다는 특징이 있다.

각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우에는 MySQL이 메모리 공간을 할당조차도 하지 않을 수도 있다

커넥션이 열려 있는 동안 계속 할당된 상태로 남아 있는 공간(커넥션 버퍼, 결과 버퍼)과 쿼리르 실행하는 순간에만 할당하고 다시 해제하는 공간(소트 버퍼, 조인 버퍼) 존재

대표적인 예시는 사진 참고

플러그인 스토리지 엔진 모델 : 데이터 읽기/쓰기 개인 or 회사가 커스텀해서 사용 가능ㅅ

생각보다 데이터 읽기/쓰기가 상당히 달라질 수 있음

mysql은 스토리지 엔진 말고 다른 다양한 플러그인 존재

핸들러 : mysql이 스토리지 엔진을 조정하기 위한 것

## 컴포넌트

mysql 8.0부터 플러그인을 보완하기 위해 나옴

플러그인 단점

플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신할 수 없음
플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음（캡슐화 안 됨）
플러그인은 상호 의존 관계를설정할 수없어서초기화가 어려움

컴포넌트는 직접 개발해보면서 익히는 거 추천

![image.png](4%201%20mysql%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A7%2023bc68478a0a806e832bdaa463ce23cc/image%203.png)

쿼리 파서 : 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만들어 내서 기본 문법 오류 발견

전처리기 : 

파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다. 각 토
큰을 테이블 이름이나 칼럼 이름, 또는 내장 함수와 같은 개체를 매핑해 해당 객체의 존재 여부와 객체
의 접근 권한 등을 확인하는 과정을 이 단계에서 수행한다. 실제 존재하지 않거나 권한상 사용할 수 없
는 개체의 토큰은 이 단계에서 걸러진다.

옵티마이저 :

DBMS의 두뇌, 사용자 요청을 어떻게 하면 가장 빠르게 처리할 지 결정, 굉장히 중요

실행엔진 :

회사로 치면 옵티마이저는 회사 경영진, 실행엔진은 중간 관리자, 핸들러는 실무자

실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청의 입력으로 연결하는 역할을 수행

핸들러(스토리지엔진):

핸들러는 MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할

복제 : 다음에

쿼리 캐시 : 웹에서 활용됐었지만 제거됨

스레드 풀 : mysql 기업 에디션에 있음.  Percona Server에서 제공하는 스레드 풀을 알아보자. 플러그인 기반

스레드 풀은 내부적으로 사용자의 요청을 처리하는 스레드 개수를 줄여서 동시 처리되는 요청이 많다
하더라도 MySQL 서버의 CPU가 제한된 개수의 스레드 처리에만 집중할 수 있게 해서 서버의 자원 소
모를 줄이는 것이 목적이다

## 트렌지션 지원 메타데이터

데이터베이스 서버에서 테이블의 구조 정보와 스토어드 프로그램 등의 정보

원래는 파일 기반으로 관리하다가 트랜잭션 지원을 안 해서 깨지는 문제 발생

MySQL 8.0 버전부터는 이러한 문제점을 해결하기 위해 테이블의 구조 정보나 스토어드 프로그램의 코
드 관련 정보를 모두 InnoDB의 테이블에 저장

시스템 테이블과 데이터 딕셔너리 정보를 모두 모아서 mysql DB에 저장하
고 있다. mysql DB는 통째로 mysql.ibd라는 이름의 테이블스페이스에 저장된다. 그래서 MySQL 서버
의 데이터 디렉터리에 존재하는 mysql.ibd라는 파일은 다른 *.ibd 파일과 함께 특별히 주의해야 한다.

MySQL 서버는 InnoDB 스토리지 엔진 이외의 스토리지 엔진을 사용하는 테이블들을
위해 SDI(Serialized Dictionary Information) 파일을 사용