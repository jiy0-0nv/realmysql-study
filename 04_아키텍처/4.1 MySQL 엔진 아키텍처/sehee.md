# 4.1 MySQL 엔진 아키텍처 ⚙️🛠️

## 🔹 MySQL 전체 구조

MySQL 서버는 크게 **MySQL 엔진**과 **스토리지 엔진**으로 구분

| 구분           | MySQL 엔진                                          | 스토리지 엔진                                               |
|----------------|-----------------------------------------------------|--------------------------------------------------------------|
| 핵심 구성 요소 | 커넥션 핸들러, SQL 파서 및 전처리기, 옵티마이저     | InnoDB, MyISAM 등의 스토리지 엔진 존재                           |
| 주요 역할      | SQL 요청 분석, 실행 계획 수립 등 DBMS의 두뇌 역할   | 실제 데이터를 디스크 스토리지에 저장하거나 읽어오는 부분 담당      |
| 개수           | 하나만 존재                                          | 여러 개 동시에 사용 가능 (테이블 단위로 지정 가능)           |

> 💡 예시 
> ```sql
> CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;
> ```
> 이렇게 테이블에 스토리지 엔진을 지정하면  
> 해당 테이블의 읽기, 변경 등의 작업을 스토리지 엔진이 처리!!

**핸들러 요청**: 스토리지 엔진에 데이터 쓰기 또는 읽기를 요청  
-> 핸들러 API 사용!

> ```sql
> SHOW GLOBAL STATUS LIKE 'Handler%';
> ```
> 핸들러 API가 어떤 작업을 했는지 확인 가능!

✅ MySQL 엔진은 쿼리를 처리하고, 핸들러를 통해 스토리지 엔진에 데이터 작업을 요청함


## 🔹 MySQL 스레딩 구조

MySQL 서버는 **스레드 기반 구조**로 작동하며,    
크게 **포그라운드 스레드**와 **백그라운드 스레드**로 구분
> 필요 시, 명령어로 서버에서 실행 중인 스레드 목록 확인 가능!

### ① 포그라운드 스레드 (클라이언트 스레드)

- 서버에 접속된 클라이언트 수만큼 존재 
- 사용자의 쿼리 요청을 처리
- 작업 완료 후 스레드 캐시로 돌아감 
(※ 시스템 변수로 개수 조절 가능)
- 데이터는 **버퍼/캐시에서 우선 조회**, 없으면 디스크에서 로딩

### ② 백그라운드 스레드 (InnoDB)

- InnoDB 스토리지 엔진에서 동작
- **로그 스레드**, **쓰기 스레드** 등이 존재
- 쓰기 스레드는 매우 많은 작업을 백그라운드로 처리하므로 **여러 개 존재** (※ 시스템 변수로 개수 조절 가능)

✅ 클라이언트마다 스레드를 생성하고, InnoDB는 백그라운드 스레드 활용


## 🔹 메모리 할당 및 사용 구조

MySQL 메모리 공간은 크게 **글로벌 메모리 영역**과 **로컬 메모리 영역**으로 구분  
시스템 변수로 설정해 둔 만큼 운영체제로부터 메모리 할당!

| 구분           | 글로벌 메모리 영역                             | 로컬 메모리 영역                                |
|----------------|--------------------------------------------------|--------------------------------------------------|
| 스레드 수와 관계 | 클라이언트 수와 무관                           | 클라이언트 수만큼 개별적으로 증가               |
| 공유 여부       | 모든 스레드가 공유                              | 각 스레드가 독립적으로 사용                     |
| 주요 용도       | 서버 전체가 공통으로 사용하는 캐시/버퍼        | 쿼리 실행 중 임시 작업 공간                     |
| 예시 구성 요소  | InnoDB 버퍼 풀, 테이블 캐시, 리두 로그 버퍼 등 | 커넥션 버퍼, 정렬 버퍼, 조인 버퍼 등            |

✅ MySQL은 메모리를 글로벌과 로컬로 나눠, 공유되거나 스레드별로 독립적으로 사용함


## 🔹 플러그인 스토리지 엔진 모델

- MySQL의 독특한 구조
- 사용자가 직접 스토리지 엔진 개발 가능
- 대부분의 작업이 MySQL 엔진에서 처리되고 마지막 데이터 읽기, 쓰기만 스토리지 엔진에서 처리
- 스토리지 엔진 외에도 다양한 기능을 플러그인 형태로 지원

> 💡 참고 명령어
> ```sql
> SHOW ENGINES;   -- 스토리지 엔진 종류
> SHOW PLUGINS;   -- 플러그인 전체 목록
> ```

✅ 다양한 스토리지 엔진과 기능을 플러그인 형태로 유연하게 확장 가능

## 🔹 컴포넌트

- 기존 플러그인 아키텍처의 단점(플러그인끼리 통신 불가, 캡슐화 불가, 의존성 낮음 등)을 개선하기 위해 도입
- MySQL 8.0부터 본격적으로 적용
- 예시: 비밀번호 검증 기능

📌 플러그인은 기능 확장을 위한 외부 모듈이고,
컴포넌트는 내부 구조 개선을 위한 모듈 시스템!

✅ 플러그인의 한계를 보완한 모듈 시스템으로, 내부 기능 간 연결과 캡슐화가 가능함


## 🔹 쿼리 실행 구조

1. **쿼리 파서**  
쿼리 문장을 토큰으로 분리해 트리 형태의 구조로 만드는 작업  
이 단계에서 문법 오류 발견

2. **전처리기**  
파서 트리 기반으로 쿼리 문장에 구조적인 문제점 점검
각 토큰을 사용할 수 있는지!

3. **옵티마이저**  
쿼리 문장을 처리하는 최적의 계획 수립 (=DBMS의 두뇌)

4. **실행 엔진**  
옵티마이저가 만든 계획 실행  
각 핸들러에게 요청하고 받은 결과를 또다른   핸들러에게 요청하도록 연결하는 역할  

5. **핸들러 (스토리지 엔진)**  
MySQL 엔진의 요청에 따라 데이터 저장/읽어오는 역할

✅ 파서 → 전처리기 → 옵티마이저 → 실행 엔진 → 핸들러 순으로 쿼리가 처리됨


## 🔹 스레드 풀

MySQL 서버 엔터프라이즈 에디션에서 지원  
커뮤니티 에디션는 스레드 풀을 미지원하지만,  
Percona Server 스레드 풀은 플러그인 형태로 커뮤니티 에디션에서도 사용 가능

목적: 불필요한 스레드 생성을 줄여 서버 자원 소모 감소  
기본적으로 CPU 코어 개수만큼 스레드 그룹 생성하는데,
시스템 변수로 조정 가능!  
선순위 큐, 후순위 큐를 이용해 특정 쿼리를 우선적으로 처리 가능

✅ 스레드를 미리 생성해 재사용하고, 우선순위 큐로 성능을 향상시키는 구조


## 🔹 트랜잭션 지원 메타데이터

**메타데이터**: 테이블 구조, 인덱스, 스토어드 프로그램 등의 DB 객체에 대한 정보  
파일 기반 메타데이터는 생성 및 변경 작업이 트랜잭션 지원 안함  
-> 작업 중 실패하면 데이터베이스나 테이블이 깨지는 문제  
-> InnoDB 테이블에 저장하도록 개선!

📌 트랜잭션이란?  
하나의 작업 단위로 묶어서 반드시 전부 성공하거나 전부 실패하도록 보장하는 처리 방식
- 예시: 은행 계좌 이체

InnoDB 스토리지 엔진을 사용하지 않을 시에는,
SDI 파일 사용!
- 메타 데이터를 JSON 형태로 직렬화하여 관리

✅ MySQL 8.0부터 메타데이터도 InnoDB에 저장되어 트랜잭션으로 보호됨