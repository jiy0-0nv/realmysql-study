
# 📦 MySQL 엔진 아키텍처 정리

## 1.  MySQL 전체 구조

- **MySQL 엔진**
  - 커넥션 핸들러, SQL 파서 & 전처리기, 옵티마이저 등
- **스토리지 엔진**
  - 실제 데이터를 디스크에 저장하거나 읽는 역할
  - 대표: `InnoDB`(버퍼 풀), `MyISAM`(키 캐시)
- **핸들러 API**
  - MySQL 엔진이 스토리지 엔진과 통신할 때 사용하는 인터페이스
  - 쿼리 실행기 → 핸들러 → 각 스토리지 엔진에게 읽기/쓰기 요청

## 2.  스레딩 구조

MySQL은 **스레드 기반 구조**를 사용하며,
다음과 같이 **포그라운드 / 백그라운드 스레드**로 구분됨. \
(스레드: 프로세스 내에서 실행되는 하나의 작업 단위, 같은 메모리 공간을 공유)

###  포그라운드 스레드
- **클라이언트 수만큼 생성**
- 클라이언트 수만큼 존재하여, 클라이언트의 쿼리 요청 처리
- 데이터 버퍼/캐시 우선 접근, 없으면 디스크에서 데이터 접근
- 커넥션 종료 시, **스레드 캐시에 반환**
- 캐시 수 설정: `thread_cache_size`

###  백그라운드 스레드 (InnoDB)
- 로그를 디스크로 기록
- 버퍼의 데이터를 디스크에 저장
- 쓰기 작업을 버퍼링하여 일괄 처리

## 3.  메모리 구조

- **글로벌 메모리 영역**  
  - 서버 전체에서 공유되는 메모리
- **로컬 메모리 영역**  
  - 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역
  - 클라이언트 스레드마다 독립적으로 할당, 절대 공유되지 않음 
  - 예: 소트 버퍼, 조인 버퍼 등 → 필요할 때만 할당됨

## 4.  플러그인 스토리지 엔진 모델

- 부가적 기능을 제공하는 스토리지 엔진을 **플러그인 형태로 추가** 가능
- 검색어 파서, 인증 기능 등도 플러그인으로 구현 가능

## 5.  컴포넌트 아키텍처

플러그인 아키텍처의 한계를 극복하기 위해 도입된 구조

###  플러그인 아키텍처의 한계
- 플러그인끼리 **직접 통신 불가**
- **MySQL 내부 함수/변수에 직접 접근** (유지보수 어려움)
- 플러그인 간 **의존 관계 명시 불가**

###  컴포넌트 아키텍처의 장점
- 컴포넌트 간 **서비스 형태로 통신 가능**
- 내부 API 호출 대신 **표준화된 인터페이스 사용**
- **의존성 명시 가능**, 동적 로딩/언로딩 지원

## 6.  쿼리 실행 구조

1. **쿼리 파서**  
   → 쿼리 문장을 토큰화해 트리 구조 생성 (문법 오류 검출)

2. **전처리기**  
   → 토큰과 개체를 매핑하여 해당 개체 존재 여부, 권한 검증

3. **옵티마이저**  
   → 가장 효율적(비용, 속도 측면)인 실행 계획 수립

4. **실행 엔진**  
   → 계획에 따라 핸들러에게 요청, 받은 결과를 또 다른 핸들러에게 요청

5. **핸들러 (스토리지 엔진)**  
   → 실제 데이터 읽기/쓰기 수행

## 7.  쿼리 캐시 (제거됨)

- 실행 결과를 메모리에 캐시, 동일한 쿼리가 들어오면 캐시에 저장된 결과를 즉시 반환
- **MySQL 8.0에서 제거됨**

## 8.  스레드 풀

- 내부적으로 **스레드 수를 제한**하여 자원 효율성 향상
- 기본적으로 CPU 코어 수만큼 **스레드 그룹 생성**
- **타이머 스레드**가 각 그룹 상태 모니터링
  - `pool_stall_limit` 시간 내에 작업 완료 못하면 스레드 추가

### 추가 기능
- **선순위/후순위 큐**로 트랜잭션 우선 처리 가능

## 9. 트랜잭션 메타데이터 관리

- 테이블 구조, 스토어드 프로그램 등 **메타데이터 관리**
- **InnoDB 테이블**에 저장
- `MyISAM`, `CSV` 등은 **SDI 파일**에 별도 저장
