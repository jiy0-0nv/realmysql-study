# 4.1 MySQL 엔진 아키텍처

## 4.1.1 MySQL의 전체 구조

MySQL(또는 MySQL 서버)는 **MySQL 엔진** / **스토리지 엔진**으로 구분된다.

<img src="https://sunset-cross-5c6.notion.site/image/attachment%3A8fd7c68d-0ad3-4da3-ba7d-cda8e33a77ef%3Aimage.png?table=block&id=23bf0a45-4b12-80f3-99a4-cd8b8222677c&spaceId=b32cad9e-5198-45a7-abbc-149012173af2&width=1030&userId=&cache=v2" width=500px>


### MySQL 엔진

- DBMS의 두뇌
  - 요청된 SQL 문장을 분석, 최적화

- 구성
  - **커넥션 핸들러**(Connection Handler): 클라이언트의 접속 요청을 처리
    - 클라이언트의 접속 요청을 받아 인증
    - 세션 생성·관리
    - 세션별 리소스 할당과 연결 유지를 담당
    - 연결 종료 시 자원 해제
  - SQL 인터페이스(SQL Interface)
    - 애플리케이션과 MySQL 서버 간의 통신 계층
    - 쿼리 전송 및 결과 반환을 수행
    - 다양한 클라이언트를 지원
  - **SQL 파서**(SQL Parser): 클라이언트의 쿼리 요청을 처리
    - 클라이언트가 보낸 SQL 문을 토큰화(tokenize) -> 구문 트리(parse tree)로 변환
    - (구문 분석 단계) 문법 오류 검출
    - 옵티마이저에 전달할 내부 표현(IR) 생성
  - **SQL 옵티마이저**(SQL Optimizer): 쿼리 실행 최적화
    - 파서가 생성한 내부 표현을 바탕으로 가능한 실행 계획을 탐색하고 
    - 비용 모델을 이용하여 최적 실행 경로를 선택
    - 인덱스 사용, 조인 순서, 병렬 처리 여부 등을 결정
  - 캐시/버퍼(Cache/Buffer)
    - 디스크 I/O 최소화를 위해 데이터를 메모리에 저장 및 관리
    - 버퍼 풀(buffer pool): 자주 사용되는 데이터 페이지 보관
    - 쿼리 성능 및 동시성 처리 능력 향상
  
- 표준 SQL(ANSI SQL) 문법 지원 -> 타 DBMS와 호환
  - 기본적인 `SELECT`, `INSERT`, `UPDATE`, `DELETE` 같은 DML(Data Manipulation Language) 문은 대체로 호환
  - 고유 문법이나 함수는 타 DBMS에서 지원되지 않거나 동작이 다를 수 있음

### 스토리지 엔진

- DBMS의 손발
  - 실제 데이터를 디스크 스토리지에 저장
  - 디스크 스토리지로부터 데이터 로드

- 한 서버에서 여러 개의 스토리지 엔진을 동시 사용 가능
  - 예제) 테이블이 사용할 스토리지 엔진 지정하기
    
    ```sql
    CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB
    ```
    - 이후 `test_table`의 모든 읽기/변경 작업은 `INNODB`가 처리

- 스토리지 엔진의 종류 (테이블 생성 시 지정)
  - `MyISAM`: 키 캐시(Key Cache) 기능
    - 인덱스 블록을 메모리에 저장
    - 인덱스 조회 시 디스크에서 직접 로드X 이미 메모리에 올라온 블록 참조 -> 응답 속도 향상
    - but 테이블 데이터 자체는 디스크에 직접 접근 -> 대용량 데이터 조회 효율 낮음
  - `InnoDB`: 버퍼 풀(Buffer Pool) 기능
    - 데이터 페이지와 인덱스 페이지를 모두 메모리에 저장 (통합 캐시 공간)
    - 읽기/쓰기 모두 버퍼 풀을 통해 처리
    - 변경된 페이지는 지연 쓰기(dirty page)로 표시되어 배치 단위로 디스크에 기록
    - LRU(Least Recently Used)로 페이지 교체 관리
    - flush로 데이터 무결성, 영속성 보장
      <br>(주기적으로 또는 트랜잭션 커밋마다 dirty page를 디스크 스토리지에 기록)
    - redo log로 복구 기능 보장
      <br>(트랜잭션 커밋 전 변경 내용을 먼저 로그 파일에 기록)
  - `MEMORY`
    - 테이블 데이터를 디스크에 저장하지 않고 서버 RAM에만 보관
    - 빠른 읽기/쓰기
    - 서버 재시작 시 데이터 소실
    - 영속성이 필요 없는 임시 테이블/캐시/세션 저장 등에 사용

### 핸들러 API
- 핸들러 요청(Handler Request)
  - MySQL 서버 엔진이 스토리지 엔진에 특정 작업을 수행하라고 지시하는 API 호출
  - 스토리지 엔진 종류에 상관없이 일관된 방식으로 데이터 작업 수행 가능
    - 테이블 오픈 시 엔진이 제공하는 핸들러 함수(함수 포인터)를 등록
    - API 레벨에서는 함수 포인터를 통해 엔진별 구현으로 바로 호출
    - 매번 엔진 종류를 검사하지 않고도 동일한 핸들러 인터페이스로 서로 다른 알고리즘 실행 (분기X 다형성O)

- 저수준 I/O 연산을 위임
    - `handler_open`: 테이블 열기
    - `handler_read_next`: 다음 행 읽기
    - `hanlder_write`: 새로운 행 삽입
    - 등등...
  
- 예제) 각 API의 호출 횟수 확인하기
  ```sql
  SHOW GLOBAL STATUS LIKE 'Handler%';
  ```
  - 인덱스가 효과적으로 사용되고 있는지, 성능 병목이 발생하는지 등을 파악할 수 있음

## 4.1.2 MySQL 스레딩 구조

MySQL 서버는 프로세스 기반이 아닌 **스레드 기반**으로 작동한다.
  
  <img src="https://sunset-cross-5c6.notion.site/image/attachment%3Aa3128d72-b84e-45be-a1c1-eec1cfe28e70%3Aimage.png?table=block&id=23bf0a45-4b12-8013-a624-dfb23a5745b2&spaceId=b32cad9e-5198-45a7-abbc-149012173af2&width=1030&userId=&cache=v2" width=600>

- 예제) MySQL 서버에서 실행 중인 스레드 목록 확인하기
  ```sql
  SELECT thread_id, name, type, processlist_user, processlist_host 
  FROM performance_schema.threads ORDER BY type, thread_id；
  ```
  - `performance_schema` 데이터베이스의 `threads` 테이블 조회
  - 스레드 타입(백그라운드, 포그라운드) 확인 가능
  - 동일 이름 스레드가 2개 이상 -> 여러 스레드가 동일 작업을 병렬로 처리

### 포그라운드*Foreground* 스레드 (클라이언트 스레드)
- 클라이언트가 접속할 때마다 생성
  - 전통적 스레드 모델: 커넥션 당 하나의 스레드 생성
  - 스레드 풀(Thread Pool) 모델: 하나의 스레드가 여러 개의 커넥션 요청 전담
- 해당 세션의 쿼리 파싱, 결과 반환
- 동시 접속 수 증가 -> 포그라운드 스레드 수 증가 -> 자원 소모량 증가
- 클라이언트 연결이 종료되면 일정 기간 메모리에 보관(스레드 캐시) 후 새 연결이 들어올 때 재사용
    - 스레드 생성/파괴 오버헤드 절약
    - `thread_cache_size` 설정 수만큼의 유휴 스레드 유지
  
- 데이터 읽기 위치 우선순위
  1. 데이터 버퍼, 캐시
  2. 디스크, 인덱스 파일

- 데이터 쓰기 위치
  - MyISAM: 포그라운드 스레드가 디스크 쓰기 작업 처리
  - InnoDB: 데이터 버퍼/캐시 쓰기는 포그라운드가 처리 -> 이후 디스크 쓰기는 백그라운드 스레드가 처리
    
### 백그라운드(Background) 스레드: 
- 상시 실행
- 시스템 유지/관리 작업 수행

- InnoDB의 백그라운드 스레드
  - 로그 스레드: redo log 관리
  - 쓰기 스레드: 버퍼의 데이터를 디스크에 기록
  - 읽기 스레드: 필요한 데이터 페이지를 미리 read
  - Purge 스레드: MVCC를 위해 오래된 트랜잭션 버전(undo 로그) 정리
  - 통계 갱신 스레드: 옵티마이저가 사용하는 테이블/인덱스 통계를 주기적으로 수집/갱신
  - 이벤트 스케줄러 스레드: 사용자가 정의한 스케줄 이벤트를 주기적으로 실행
  
- 클라이언트 요청과 독립적으로 비동기 작업 처리

## 4.1.3 메모리 할당 및 사용 구조

- 글로벌 메모리 영역/로컬 메모리 영역으로 구분
- 전체 메모리를 할당하거나/일부만 할당 후 나머지는 예약

### 글로벌 메모리 영역

- 클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당
  - 2개 이상을 할당받을 수 있지만 클라이언트의 스레드 수와는 무관
  - 모든 글로벌 영역은 모든 스레드가 공유

- 종류
  - 테이블 캐시
  - InnoDB 버퍼 풀
  - InnoDB 어댑티드 해시 인덱스
  - InnoDB redo log 버퍼

### 로컬 메모리 영역 (세션 메모리 영역)

- 클라이언트 스레드가 쿼리 처리를 위해 사용하는 메모리 영역
- 커넥션 버퍼, 정렬(소트) 버퍼 등
- 각 클라이언트 스레드별로 독립적으로 할당 (공유되지 X)
- 각 쿼리의 용도별로 필요할 때만 공간 할당
- 커넥션이 열려 있는 동안 계속 할당된 상태(커넥션, 결과 버퍼)일 수도 있고 쿼리 실행 순간에만 할당했다가 해제(소트, 조인 버퍼)될 수도 있음

- 종류
  - 정렬 버퍼 (Sort Buffer)
  - 조인 버퍼
  - 바이너리 로그 캐시
  - 네트워크 버퍼

## 4.1.4 플러그인 스토리지 엔진 모델

- 기본 제공 스토리지 엔진이 아닌 사용자가 개발한 맞춤 스토리지 엔진을 사용할 수 있음
- 인증, 검색 파서, 쿼리 재작성 등도 플러그인으로 제작 가능

## 4.1.5 컴포넌트

- 기존의 플러그인 아키텍처의 단점을 보완
  1. 플러그인은 오직 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신이 불가능
  2. 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음 (캡슐화 X)
  3. 플러그인은 상호 의존 관계 설정 불가. 초기화 어려움

## 4.1.6 쿼리 실행 구조

### 쿼리 파서
- SQL 문장을 토큰화하고 구문 트리(parse tree)를 생성
- 문법 오류를 검출하고 파싱 단계에서 차단

### 전처리기
- 테이블·컬럼 이름 해석 및 존재 여부를 확인
- 뷰 치환(view substitution)과 권한 검사를 수행

### 옵티마이저
- 가능한 여러 실행 계획을 생성하고 비용(cost)을 평가
- 인덱스 사용 여부, 조인 순서, 병렬 처리 여부 등을 최적화

### 실행 엔진
- 옵티마이저가 선택한 계획에 따라 연산자(operator)를 순차적으로 실행할 수 있음
- 중간 결과를 조합하고 최종 결과를 반환할 수 있음

### 핸들러
- 스토리지 엔진의 저수준 I/O 작업을 호출할 수 있음
- `handler_read`, `handler_write` 등 공통 인터페이스로 데이터 접근을 위임할 수 있음

## 4.1.8 쿼리 캐시
- SELECT 결과를 SQL 문자열 키-값 형태로 메모리에 저장
- 동일한 쿼리가 반복될 경우 디스크 접근 없이 캐시된 결과를 빠르게 반환
- 관련 테이블에 INSERT/UPDATE/DELETE가 발생하면 자동으로 해당 캐시를 무효화

## 4.1.9 스레드 풀
- 서버 시작 시 워커 포그라운드 스레드를 미리 생성하여 대기
- 새로운 연결이 들어오면 캐시된 스레드를 재사용 -> 스레드 생성 오버드 절약
- `thread_cache_size`: 유지할 유휴 스레드 수를 조정

## 4.1.10 트랜잭션 지원 메타데이터
- Undo 로그와 Redo 로그 등 트랜잭션 로그 관리
- 각 트랜잭션의 ID와 상태(CMMIT, ROLLBACK 등) 저장
- 잠금(lock) 정보(행 수준, 테이블 수준)를 기록해 동시성 제어를 지원