# 2회차

## 4.2. InnoDB 스토리지 엔진 아키텍처

### **4.2.1 프라이머리 키에 의한 클러스터링**

- 프라이머리 키를 기준으로 클러스터링
- 프라이머리의 키 값 순서대로 디스크에 저장
- 세컨더리 인덱스는 레코드의 주소 대신 프라이머리의 키값을 논리적인 주소로 이용

### 4.2.2. 외래 키 지원

- 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요
- 변경 시에는 부모 테이블/자식 테이블에 데이터가 있는지 체크하는 작업이 필요

### **4.2.3 MVCC (Multi-Version Concurrency Control)**

- 동시성을 보장하기 위해 **MVCC** 사용.
- **Undo Log**를 통해 트랜잭션이 시작되었을 때의 데이터 상태를 보존함 (과거 상태저장)
- 기본 격리 수준은 REPEATABLE READ이며, 필요에 따라 READ COMMITTED 등으로 변경 가능.

### **4.2.4 잠금 없는 일관된 읽기**

- SELECT 쿼리는 기본적으로 **락을 걸지 않는 읽기**
- 트랜잭션의 변경 작업과 관계없이 잠금을 대기하지 않고 바로 실행
- 레코드를 변경하고 커밋 수행하지 않았더라도 다른 사용자의 SELECT 방해하지 않음

### **4.2.5 자동 데드락 감지**

- 내부적으로 Wait-for graph 형태로 주기적으로 교착 상태 탐지함.
- 데드락 감지 스레드를 통해서 잠금 대기 그래프를 검사해 교착 상태에 빠진 트랜잭션을 찾아서 강제 종료, 기준은 언두 로그의 양으로 적게 가진 트랜잭션이 롤백의 대상이 됨
- 파라미터:
    - innodb_deadlock_detect: 교착 상태 감지 기능 활성화, 과부하 일어날 수도 있기 때문에 OFF로 설정 가능
    - innodb_lock_wait_timeout: 잠금 대기 시간 설정, 일정 시간 이상 데드락 상황이 있으면 에러 메세지 반환

### **4.2.6 자동화된 장애 복구**

- 데이터베이스 손상 복구 시 innodb_force_recovery를 단계적으로 활용 가능 (0~6까지)

### 4.2.7. InnoDB 버퍼 풀

- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 정리해두는 공간
- 쓰기 작업을 지연시키고 일괄 작업으로 처리할 수 있게 해주는 buffer
- 랜덤한 디스크 작업을 버퍼에 모음

**사이즈 선택** : OS와 클라이언트 스레드, 레코드 버퍼 등이 사용하는 메모리를 고려

**구조 :** 페이지 크기로 나누어 관리

- **Free List**: 아직 사용되지 않은 빈 페이지 목록.
- **LRU 리스트**: 최근 접근 빈도에 따라 관리 (LRU + MRU 형태)
- **Flush 리스트**: 더티 페이지(변경된 페이지)를 기록 순서대로 관리
- InnoDB 스토리지 엔진에서 데이터 찾는 과정
    1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사
        1. InnoDB 어댑티브 해시 인덱스를 이용해 페이지를 검색
        2. 해당 테이블의 인덱스（B-Tree｝를 이용해 버퍼 풀에서 페이지를 검색
        3. 버퍼 풀에 이미 데이터 페이지가 있었다면 해당 페이지의 포인터를 MRU 방향으로 승급
    2. 디스크에서 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가
    3. 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동（Read Ahead와 같이 대량 읽기의 경우 디스크의 데이터 페이지가 버퍼 풀로 적재는 되지만 실제 쿼리에서 사용되지는 않을 수도 있으며, 이런 경우에는 m기로 이동되지 않음）
    4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했었는지에 따라 나이（Age）가 부여되며, 버퍼 풀에 상주하는 동안 쿼리에서 오랫동안 사용되지 않으면 데이터 페이지에 부여된 나이가 오래되고（‘Aging’이라고 함） 결국 해당 페이지는 버퍼 풀에서 제거 된다. 버퍼 풀의 데이터 페이지가 쿼리에 의해 사용되면 나이가 초기화되어 다시 젊어지고 MRU의 헤더 부분으로 옮겨진다.
    5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가
1. 버퍼 풀에 필요한 페이지가 있는지 찾음 
    1. 있으면 MRU로 승격.
    2. 없으면 디스크에서 읽고 → LRU에 추가
2. 자주 쓰이면 MRU에 오래 남음.
3. 오래 안 쓰이면 LRU 끝에서 제거.
4. 자주 사용하는 페이지는 Adaptive Hash Index에 등록됨

**버퍼풀과 리두 로그**

버퍼 풀은 데이터 캐시 + 쓰기 버퍼이고 리두 로그는 변경 사항을 기록한 로그 공간

리두 로그 파일의 공간은 계속 순환되어 재사용되지만 로그 포지션을 계속 증가 (Log Sequence Number)

주기적으로 리두 로그와 버퍼 풀의 더티페이지를 디스크로 동기화 → 가장 최근 체크포인트 지점의 LSN이 활성 리두 로그 공간의 시작점이 됨

- 이 공간이 너무 작으면 쓰기 성능 저하 (더티 페이지 제한적)
- 너무 크면 순간적인 대량 플러시 필요하기 때문에 성능 급감 가능성

**버퍼 풀 플러시**

더티 페이지를 디스크에 쓰는 작업

- 플러시 리스트 플러시 : 오래된 더티 페이지부터 순차적으로 디스크로 기록
- LRU 리스트 플러시 : 사용 빈도가 낮은 페이지를 버퍼 풀에서 제거

### 4.2.8. Double Write Buffer

리두 로그는 변경된 내용만 기록, 비정상 종료시 복구 실패 가능

**DoubleWrite Buffer**에 먼저 순차적으로 쓰고, 이후 실제 데이터 파일에 랜덤하게 기록

DoubleWrite Buffer와 데이터 파일을 비교해 손상된 페이지를 복구

### 4.2.9. 언두 로그

언두로그의 역할 : 트랜잭션 복구 (롤백시 이전 데이터를 되돌림), 격리 수준 유지 (MVCC를 위해 읽기 시 이전 버전 사용)

장시간 활성 트랜잭션 처리시 언두 로그가 삭제되지 못하고 축적됨 → 공간 문제

### 4.2.10. 체인지 버퍼

인덱스 페이지가 버퍼 풀에 없을 때 변경 내용을 임시 저장하고 추후 병합함

### 4.2.11. 리두 로그 및 로그 버퍼

트랜잭션의 영속성(Durability) 보장
로그 기록 정책  `innodb_flush_log_at_trx_commit` 

- 0: 1초 간격 동기화
- 1: 매 커밋 시 동기화
- 2: 매 커밋 시 기록하되, 동기화는 1초 주기

### 4.2.12. 어댑티브 해시 인덱스

자주 접근되는 B-Tree 인덱스 키를 해시 인덱스로 자동 관리 

- **효과적인 경우**:
    - 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우(디스크 읽기가 많지 않은 경우)
    - 동등 조건 검색（동등 비교와 IN 연산자）이 많은 경우
    - 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우
- **비효율적인 경우**:
    - 디스크 읽기가 많은 경우
    - 특정 패턴의 쿼리가 많은 경우 (조인이나 LIKE 패턴 검색)
    - 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우

### **4.2.13 InnoDB**와 **MylSAM, MEMORY** 스토리지 엔진 비교

예전에는 MyISAM이 기본 스토리지 엔진, **MySQL 5.5부터 InnoDB가 기본**이 되었지만, 일부 시스템 테이블은 계속 MyISAM 사용. **MySQL 8.0부터는 모두 InnoDB로 통일**

MEMORY 스토리지 엔진은 모든 처리를 메모리에서만 수행 → 빠르지만 동시성 약하고 잠금이 많음 (MySQL 서버는 일반적으로 온라인 트랜잭션 처리, 온라인 트랜잭션 처리에서는 동시 처리 성능 중요)

사용자의 쿼리를 처리하기 위해 내부적으로 임시 테이블 사용, MEMORY는 가변 길이 타입의 칼럼을 지원하지 않는다는 문제점, TempTable 사용