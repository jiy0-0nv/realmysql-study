# 4.2 InnoDB 스토리지 엔진 아키텍처

## 1. 프라이머리 키에 의한 클러스터링
- 프라이머리 키를 기준으로 클러스터링되어 저장 
- 모든 세컨더리 인덱스는 레코드의 주소 대신 프라이머리 키의 값을 논리적인 주소로 사용
- 쿼리의 실행 계획에서 프라이머리 키는 기본적으로 다른 보조 인덱스에 비해 비중이 높게 설정

## 2. 왜래 키 지원
- ``foreign_key_checks``: 왜래 키 관계에 대한 체크 작업 일시적으로 멈출 수 있음
    - 레코드 적재나 삭제 등 작업 빠르게 처리 가능
    - 일관성을 맞춰준 후 다시 왜래 키 체크 기능을 활성화

## 3. MVCC(Multi Version Concurrency Control)
- 언두 로그(Undo log)를 이용해 잠금을 사용하지 않는 일관된 읽기 제공
- 하나의 레코드에 대해 여러 개의 버전이 동시에 관리
- INSERT문 실행 \
→ 버퍼 풀은 새로운 값 업데이트 & 변경 전 값만 언두로그로 복사 \
→ 디스크의 데이터 파일은 업데이트 되었거나 아닐 수도 있음
- COMMIT 전에 다른 사용자가 레코드를 조회하면?
    - 설정된 격리 수준에 따라 다름!
    - ``READ_UNCOMMITED``: 버퍼 풀에 있는 데이터
    - ``READ_COMMITED``나 그 이상의 격리 수준: 커밋되지 않았으므로 언두 영역의 데이터를 반환
- COMMIT 명령 실행 시 지금 상태를 영구적인 데이터로 만들어버림

## 4. 잠금 없는 일관된 읽기
- InnoDB에서는 다른 트랜잭션이 가지고 있는 잠금을 기다리지 않고, 읽기 작업이 가능
- 특정 사용자가 레코드를 변경하고 아직 커밋하지 않아도 이 트랜잭션이 다른 사용자의 SELECT 작업을 방해하지 않음

## 5. 자동 데드락 감지
- 잠금 대기 목록을 그래프 형태로 관리
- 데드락 감지 스레드로 그래프를 검사하여 교착 상태에 빠진 트랜잭션들 중 하나를 강제 종료시킴
- 언두 로그 레코드를 더 적게 가진 트랜잭션을 강제 롤백  \
→ 서버 부하를 덜 유발
- ``innodb_table_locks``: MYSQL 엔진에서 관리되는 테이블 레벨의 잠금까지 감지 가능
- 잠금 목록이 저장된 리스트에 새로운 잠금을 걸고 데드락 스레드를 찾음
- ``innodb_dealock_detect``: 데드락 감지 스레드 활성화
- ``innodb_lock_wait_timeout``: 데드락 상황에서 일정 시간이 지나면 자동으로 요청 실패, 에러 메시지 반환

## 6. 자동화된 장애 복구
- 완료되지 못한 트랜잭션이나 디스크에 일부만 기록된 데이터 페이지 등에 대한 복구
- MySQL 서버 시작 시 항상 자동 복구를 수행
- 서버가 시작되지 않으면, 백업 or 바이너리 로그를 사용해 복구

## 7. InnoDB 버퍼 풀
- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간
- 쓰기 작업을 지연시켜 일괄 작업으로 처리해줄 수 있게 해주는 버퍼 역할

### 크기 설정
- 운영체제와 각 클라이언드 스레드가 사용할 메모리를 고려
- 동적으로 크기 조절이 가능해짐
- 버퍼 풀 인스턴스: 버퍼 풀이 여러개로 쪼개진 형태, 내부 잠금 경합 문제를 개선 가능

### 구조
- 페이지 크기의 조각으로 쪼개어 데이터가 필요하면 해당 데이터 페이지를 읽어서 각 조각에 저장
- LRU(Least Recently Used) 리스트와 플러시(Flush) 리스트, 그리고 프리(Free) 리스트라는 3개의 자료구조를 관리
- 프리 리스트
    - 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록
    - 사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용
- LRU 리스트
    - LRU + MRU(Most Recently Used) 리스트가 결합된 경태
    - 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 InnoDB 버퍼 풀의 메모리에 유지하여 디스크의 읽기를 최소화하는 목적
    - If 필요한 레코드가 버퍼 풀에 저장 \
    → 버퍼 풀에서 페이지를 검색, 해당 페이지의 포인터를 MRU 방향으로 승급
    - Else 디스크에서 필요한 데이터 페이지를 적재, 그 페이지의 포인터를 LRU 헤더 부분에 추가
    - LRU 헤더 부분에 적재된 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동
    - 쿼리에서 오랫동안 사용되지 않으면 버퍼 풀에서 제거, 사용되면 나이 초기화 및 MRU 헤더 방향으로 이동
- 플러시 리스트
    - 디스크로 동기화되지 않은 데이터를 가진 데이터 페이지의 변경 시점 기준의 페이지 목록을 관리
    - 데이터 변경이 가해진 페이지는 플러시 리스트에 관리
    - InnoDB는 데이터의 변경 내용을 리두 로그에 기록하고 버퍼 풀의 데이터 페이지에도 변경 내용을 반영
### 리두 로그
- 버퍼 풀의 역할인 데이터 캐시 + 쓰기 버퍼링 중 쓰기 버퍼링과 연관
- 여러 개의 고정 크기 파일을 연결해서 순환 고리처럼 사용 \
→ 데이터 변경이 계속 발생하면 기록된 로그 엔트리는 어느 순간 다시 새로운 로그 엔트리로 덮어 쓰임
- 활성 리두 로그: 리두 로그 파일에서 재사용 불가능한 공간
- InnoDB 스토리지 엔진은 주기적으로 체크포인트 이벤트를 발생시켜 리두 로그와 버퍼 풀의 더티 페이지를 디스크로 동기화
### 버퍼 풀 플러시
- 플러시 리스트 플러시
    - 주기적으로 호출하여 더티 페이지를 디스크로 동기화하고 오래된 리두 로그 엔트리의 사용 공간을 비우는 것
    - 클리너 스레드: 더티 페이지를 디스크로 동기화 하는 스레드
    - 버퍼 풀은 더티 페이지를 많이 가지고 있을수록 디스크 쓰기 작업을 버퍼링 하여 여러번의 디스크 쓰기를 한 번으로 줄이는 효과를 극대화 가능 \
    but, 디스크 쓰기 폭발(Disk IO Burst) 현상이 발생할 가능성이 높아짐
    - 어댑티브 플러시: 단순히 버퍼 풀의 더티 페이지 비율이나 환경 변수 설정값에 의존하지 않고, 리두 로그의 증가 속도를 분석해서 적절한 수준의 더티 페이지가 버퍼 풀에 유지될 수 있도록 디스크 쓰기를 실행
- LRU 리스트 플러시
    - 사용 빈도가 낮은 데이터 페이지들을 제거

### 상태 백업 및 복구
- 버퍼 풀 덤프 및 적재 기능으로 버퍼 풀의 상태를 백업 가능
- LRU 리스트에서 적재된 데이터 페이지의 메타 정보만을 가져와 저장 → 매우 빠름
- 다시 버퍼 풀로 복구하는 과정은 백업된 내용에서 데이터 페이지를 다시 디스크로부터 읽어와야하기 때문에 시간이 오래 걸릴 수 있음

### 적재 내용 확인
``innodb_cached_indexes`` 테이블 이용

## 8.  Double Write Buffer
- 더티 페이지를 디스크 파일로 플러시할 때 문제 발생 시 사용
- 버퍼 풀에 기록 전에 더티 페이지를 우선 묶어 디스크 쓰기로 시스템 테이블스페이스의 DoubleWrite 버퍼에 기록
- 엔진이 재시작 될 때 DoubleWrite 버퍼와 데이터 파일의 페이지들을 비교해서 다르면 DoubleWrite 버퍼의 내용을 데이터 파일의 페이지로 복사

## 9. 언두 로그
트랜잭션과 격리 수준 보장을 위해 DML로 변경되기 이전 버전의 데이터를 백업한 것
- 용도
    - 트랜잭션의 롤백 대비용
    - 트랜잭션의 격리 수준을 유지하면서 높은 동시성 제공
- 테이블스페이스(저장 공간) 구조
    - 언두 테이블스페이스 > 롤백 세그먼트 > 언두 슬롯

## 10. 체인지 버퍼
INSERT나 UPDATE 시 인덱스 업데이트 작업을 해야하는데, \
버퍼 풀에 해당 인덱스 페이지가 있지 않아 디스크로부터 읽어와서 업데이트 해야한다면
임시 공간에 저장해두었다가 나중에 인덱스 페이지가 버퍼 풀로 올라오면 업데이트

## 11. 리두 로그 및 로그 버퍼
### 리두 로그
서버가 비정상적으로 종료됐을 때 데이터 파일에 기록되지 못한 데이터를 잃지 않게 해주는 안전장치
- 데이터 파일은 읽기 성능을 고려한 자료구조를 가지고 있어, DB 서버는 쓰기 비용이 낮은 자료구조를 가진 리두 로그를 가짐.
- 커밋되었지만 데이터 파일에 기록되지 않았을 때, 리두 로그에 저장된 데이터를 데이터 파일에 다시 복사
- 리두 로그 아카이빙 & 리두 로그 비활성화

## 12. 어댑티브 해시 인덱스
사용자가 수동으로 생성하는 인덱스가 아니라 InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스
- 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 만들고, 필요 시 어댑티브 해시 인덱스를 검색 → B-Tree 검색 시간을 줄여줌 
- 인덱스 키 값 - 데이터 페이지 주소 쌍으로 관리
    - 인덱스 키 값은:  B-tree 인덱스의 고유번호와 B-tree 인덱스의 실제 키 값 조합으로 생성
- 테이블 삭제/변경 시, 테이블이 가진 모든 데이터 페이지의 내용을 어댑티브 해시 인덱스에서 제거 해야해서 CPU 자원을 상당히 많이 잡아먹음


# 3. MyISAM 스토리지 아키텍처
## 1. 키 캐시
