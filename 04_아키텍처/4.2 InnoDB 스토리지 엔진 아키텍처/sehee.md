# 4.2 InnoDB 스토리지 엔진 아키텍처

InnoDB는 거의 유일하게 **레코드 기반 잠금**을 제공하는 스토리지 엔진으로,  
**높은 동시성**, **안정성**, **우수한 성능**이 특징!


## 🔹 키

### ① 프라이머리 키

- InnoDB 테이블은 **프라이머리 키를 기준으로 클러스터링**
- **세컨더리 인덱스**가 프라이머리 키 값을 참조해 빠른 스캔 가능
- 보조 인덱스보다 **우선순위가 높음**
- MyISAM 스토리지 엔진은 **프라이머리 키 클러스터링 미지원**

### ② 외래 키

- **부모/자식 관계**를 정의하는 제약 조건
- **두 테이블 모두 인덱스 생성 필요**
- 데이터가 존재할 경우 제약 조건 위반 가능 → 작업 전 확인 필요
- 외래 키 제약이 복잡할 경우 작업이 어려움 → **외래 키 검사 일시 중지 가능**

> ```sql
> SET foreign_key_checks=OFF;
> -- // 작업 실행
> SET foreign_key_checks=ON;
> ```

> 💡 참고
> 외래 키 체크를 끈 상태에서 부모 테이블의 레코드를 삭제한 경우,  
> 자식 테이블의 레코리도 삭제한 후 외래 키 체크 기능을 다시 활성화해야 함


## 🔹 MVCC

InnoDB는 **MVCC**를 통해 **잠금 없이 일관된 읽기(consistent read)** 제공!  

- **목적**: 트랜잭션 간 충돌 없이 동시에 데이터를 읽을 수 있도록 함
- **구현 방식**: InnoDB는 **언두 로그(undo log)** 를 사용해 MVCC 구현

---

### 🔧 작동 방식

1. `UPDATE` 쿼리 실행 시:
   - **버퍼 풀의 데이터는 새로운 값으로 변경**
   - 기존 값은 **언두 영역**에 백업

2. `COMMIT` 실행 시:
   - 변경된 데이터가 **영구 저장**

3. `ROLLBACK` 실행 시:
   - 언두 영역의 데이터를 **복원**
   - 언두 영역 내용은 **삭제**

---

### 📌 잠금 없는 일관된 읽기

- **다른 트랜잭션의 잠금을 기다리지 않고도 읽기 가능**
- 예:  
  A 사용자가 레코드를 수정하고 아직 커밋하지 않았더라도  
  B 사용자는 언두 로그를 이용해 **수정 전 데이터**를 읽을 수 있음


## 🔹 자동 데드락 감지

InnoDB는 **데드락** 발생 시 자동으로 감지하고 처리!  

- **잠금 대기 목록을 그래프 형태로 관리**
- **데드락 감지 스레드**가 주기적으로 그래프를 검사해  
  → 데드락 발생 시, **언두 로그가 더 적은 트랜잭션**을 롤백하여 해결

📌 **데드락**란?  
둘 이상의 트랜잭션이 서로의 자원을 기다리며 무한 대기하는 상태

---

### ⚙️ 시스템 변수

| 변수명                   | 설명 |
|--------------------------|------|
| `innodb_table_locks`     | 테이블 수준의 잠금까지 감지 |
| `innodb_deadlock_detect` | OFF로 설정 시, 데드락 감지 스레드 비활성화 (자원 소모 방지 목적) |
| `innodb_wait_timeout`    | 데드락 시, 일정 시간 대기 후 요청 실패 처리 |


## 🔹 자동화된 장애 복구

InnoDB는 MySQL 서버가 시작될 때 자동으로 복구 시도  
복구에 실패하면 서버는 종료되며, 이때는 `innodb_force_recovery` 옵션을 단계적으로 설정하며  
손상 지점을 확인하고 데이터 복구를 시도해야 함!

---

### `innodb_force_recovery` 옵션

| 설정값 | 의미 | 설명 |
|--------|------|------|
| **1** (`SRV_FORCE_IGNORE_CORRUPT`) | 손상 무시 | 테이블 데이터나 인덱스 페이지 손상이 있어도 무시하고 서버 시작 |
| **2** (`SRV_FORCE_NO_BACKGROUND`) | 백그라운드 스레드 중지 | 언두 데이터 삭제 중 장애 발생 시, 메인 스레드 제외하고 재시작 |
| **3** (`SRV_FORCE_NO_TRX_UNDO`) | 트랜잭션 언두 무시 | 언두 영역 무시하고 리두 로그만 적용 |
| **4** (`SRV_FORCE_NO_IBUF_MERGE`) | 인서트 버퍼 무시 | 인서트 버퍼 병합 오류 시 무시하고 재시작 (데이터 손실 거의 없음) |
| **5** (`SRV_FORCE_NO_UNDO_LOG_SCAN`) | 언두 로그 무시 | 언두 로그 완전 무시, 데이터베이스 백업 후 재구축 권장 |
| **6** (`SRV_FORCE_NO_LOG_REDO`) | 리두 로그 무시 | 리두 로그 무시하고 마지막 체크포인트 상태로 복구. DB 재구축 강력 권장 |

---

📌 설정값이 클수록 위험한 복구 방식이며,  
가능한 낮은 값부터 시도하고 **데이터 백업 후 재구축**을 고려하는 것이 안전함

📌 모든 방법이 실패하면 최후 수단은 **백업 데이터로 복원**하는 것!


## 🔹 InnoDB 버퍼 풀

디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간

### 1. 버퍼 풀의 크기 설정

- 운영체제와 각 클라이언트 스레드가 사용할 메모리를 고려해 설정  
- 작은 값(예: 50%)으로 설정한 뒤 상황을 보며 점진적으로 증가시키는 것이 최적  
- `innodb_buffer_pool_size` 변수로 동적 변경 가능  
  - 단, 크리티컬한 변경이므로 서버가 한가한 시점에 수행  
  - 특히 **크기 줄이기**는 서비스 영향이 크므로 **지양**  
- 내부 잠금 경합을 줄이기 위해 여러 개로 쪼개어 관리 가능

### 2. 버퍼 풀의 구조

- 버퍼 풀은 페이지 크기의 조각들로 나뉘어 있음  
- 스토리지 엔진이 데이터를 필요로 할 때 디스크에서 읽어 각 조각에 저장  
- 페이지 조각을 관리하기 위해 다음 세 가지 리스트를 사용:

📌 **LRU 리스트**
- 디스크에서 읽은 페이지를 최대한 오래 메모리에 유지  
- 디스크 읽기 횟수를 최소화

📌 **플러시 리스트**
- 디스크로 동기화되지 않은 **더티 페이지**를 변경 시점 기준으로 관리  
- 데이터 변경 시:
  - 리두 로그에 기록  
  - 버퍼 풀의 페이지에도 변경 반영

📌 **프리 리스트**
- 비어 있는 페이지 조각을 관리하는 리스트

### 3. 버퍼 풀과 리두 로그

- 리두 로그는 순환되어 재사용되며, 기록될 때마다 LSN 증가  
- InnoDB는 주기적으로 **체크포인트 이벤트**를 발생시켜  
  리두 로그와 버퍼 풀의 더티 페이지를 디스크에 동기화

- **리두 로그 크기가 작을 경우**:
  - 버퍼 풀에 저장 가능한 더티 페이지 수도 제한됨  
  - → 체크포인트 자주 발생 → 성능 저하 우려

- **리두 로그 크기 설정 전략**:
  - 처음에는 작게 설정하고  
  - 필요할 때마다 점진적으로 늘리는 것이 권장됨

### 4. 버퍼 풀 플러시

MySQL 8.0부터 더티 페이지 플러시 시 디스크 기록이 폭증하는 문제를 해결  
→ **2가지 플러시 방식**을 백그라운드에서 실행

📌 **플러시 리스트 플러시**
- 리두 로그 공간을 재활용하려면 **더티 페이지가 디스크에 먼저 동기화**되어야 함
- 따라서 주기적으로 **플러시 리스트 플러시 함수**를 호출

| 변수명 | 설명 |
|--------|------|
| `innodb_page_cleaners` | 더티 페이지 플러시 스레드 개수 |
| `innodb_max_dirty_pages_pct_lwm`, `innodb_max_dirty_pages_pct` | 더티 페이지 비율 상한/하한 |
| `innodb_io_capacity`, `innodb_io_capacity_max` | 디스크 I/O 처리 성능 기준 |
| `innodb_flush_neighbors` | 인접 더티 페이지 함께 플러시 여부 |
| `innodb_adaptive_flushing`, `innodb_adaptive_flushing_lwm` | 어댑티브 플러시 기능 관련 설정 |

📌 **LRU 리스트 플러시**
- LRU 리스트에서 사용 빈도가 낮은 페이지를 제거해 새로운 페이지 공간 확보  
- 해당 페이지가 더티 페이지일 경우 **디스크로 먼저 기록 후 제거**

### 5. 버퍼 풀 상태 백업 및 복구

- **워밍업**: 디스크 데이터가 이미 버퍼 풀에 적재된 상태  
  → 쿼리 처리 속도가 **몇십 배 향상**
- MySQL 5.6부터 **버퍼 풀 덤프/로드 기능 도입**
- `innodb_buffer_pool_load_abort`: 복구 중단 시 사용할 수 있는 시스템 변수

### 6. 버퍼 풀의 적재 내용 확인

- `information_schema.innodb_buffer_page` 테이블을 통해 확인 가능  
  → **주의**: 버퍼 풀이 크면 조회 시 부하 발생

- MySQL 8.0부터 `innodb_cached_indexes` 테이블 추가  
  → **인덱스별 적재 상태**를 확인할 수 있음


## 🔹 Double Write Buffer

- 리두 로그는 **변경된 부분만 기록** → 손상 시 일부 데이터만 저장될 위험 존재
- 이를 방지하기 위해 데이터 페이지를 **DoubleWrite 버퍼**에 먼저 기록
- 이후 실제 데이터 파일에 기록하며, **쓰기 실패 시 DoubleWrite 버퍼에서 복구 가능**
- `innodb_doublewrite` 시스템 변수로 활성화 여부 제어 가능


## 🔹 언두 로그

**언두 로그**: 데이터가 변경되기 **이전의 상태를 백업**해 두는 로그
  → 트랜잭션 보장, 격리 수준 보장

📌 **트랜잭션 격리 수준**이란?
여러 트랜잭션이 동시에 실행될 때,  
**한 트랜잭션의 작업이 다른 트랜잭션에 어떤 영향을 미칠지 결정하는 기준**


1. **언두 로그 모니터링**

- 트랜잭션이 **대용량 데이터 처리** 또는 **장시간 유지**되면 언두 로그가 급격히 증가
- MySQL 8.0부터:
  - 언두 로그를 **순차적으로 관리**해 디스크 공간 절약 가능
  - 서버가 필요 없는 언두 영역을 **자동으로 정리**하기도 함
- **주의**: 장기 트랜잭션은 성능 저하 유발 → **모니터링 중요**

2. **언두 테이블스페이스 관리**

- 언두 로그가 저장되는 공간 = **언두 테이블스페이스**
- MySQL 8.0부터:
  - 기존 시스템 테이블스페이스 외부에 **별도 언두 테이블스페이스 생성**
  - **동적으로 추가/삭제** 가능

- 하나의 언두 테이블스페이스:
  - **1~128개 롤백 세그먼트** 보유
  - 각 롤백 세그먼트는 언두 슬롯을 여러 개 가짐

- **최대 동시 트랜잭션 개수 공식**:
`(InnoDB 페이지 크기) / 16 * (롤백 세그먼트 개수) * (언두 테이블스페이스 개수)`

📌 **Undo Tablespace Truncate**
- 불필요하거나 과도하게 사용된 언두 테이블스페이스 공간을 **운영체제에 반납**하는 과정
- 필요 공간만 유지하고 나머지 정리 → **디스크 절약**


## 🔹 체인지 버퍼

- 변경 대상 인덱스 페이지를 **즉시 디스크에서 읽지 않고**,  
  **체인지 버퍼라는 임시 공간에 저장** → 즉시 결과 반환 가능
- 이후 **백그라운드 스레드가 병합 작업 수행** (체인지 버퍼 머지 스레드)

- 중복 체크가 필요한 **유니크 인덱스는 사용 불가**  
- 원래는 `INSERT` 작업만 지원했으나  
  → 현재는 `INSERT`, `DELETE`, `UPDATE` 모두 지원
- `innodb_change_buffing` 시스템 변수로 제어 가능
- **버퍼 풀 메모리 공간의 25% 사용 (최대 50%)**


## 🔹 리두 로그 및 로그 버퍼

- **비정상 종료 시 데이터를 복구**하기 위해 리두 로그 사용
- 트랜잭션 커밋되면 즉시 기록되도록 시스템 변수 설정하는 것을 권장
- 로그 파일의 크기가 버퍼 풀의 효율성 결정
- 전체 리두 로그 용량 = 
  `innodb_log_file_size` × `innodb_log_files_in_group`

리두 로그 버퍼링에 사용되는 공간이 **로그 버퍼**

1. **리두 로그 아카이빙**

변경이 많은 환경에서 **복구 가능성을 높이기 위해 도입**

- 아카이브 디렉토리 설정:  
  `innodb_redo_log_archive_dirs`
- 아카이빙 시작:  
  `innodb_redo_log_archive_start('<dir>')`
- 아카이빙 종료:  
  `innodb_redo_log_archive_stop()`
- 리두 로그 정상적으로 사용하려면 커넥션 유지
  
2. **리두 로그 비활성화**

- 리두 로그 비활성화해 대용량 데이터 적재 시간 단축 가능
- 비활성화 명령어:  
  `ALTER INSTANCE DISABLE INNODB REDO_LOG;`
- 데이터 적재 완료 후 **꼭 다시 활성화**:  
  `ALTER INSTANCE ENABLE INNODB REDO_LOG;`


## 🔹 어댑티드 해시 인덱스

InnoDB는 자주 사용되는 데이터에 대해 **자동으로 어댑티브 해시 인덱스를 생성**하여  
B-Tree 검색보다 더 빠르게 접근할 수 있도록 함

- 제어 변수: `innodb_adaptive_hash_index`
- 구조:  
  - **인덱스 키 값**과 **데이터 페이지 주소**의 쌍으로 구성  
  - 키 값 = B-Tree 인덱스의 **고유 번호 + 실제 키 값** 조합
- 내부적으로 **파티션 분할**을 통해 잠금 경합 완화

---

### ⚙️ 특징

- **디스크 읽기 빈도 높은 경우엔 효과 ↓**
- **해시 인덱스에 있는 데이터 삭제 시 자원 소모 큼**
- **히트율, 메모리 사용량, CPU 사용량** 등을 고려해 활성화 여부 결정


## 🔹 스토리지 엔진 비교

- **InnoDB**: 일반적인 테이블 저장용 (기본 스토리지 엔진)
- **MyISAM**: 시스템 테이블, 전문 검색, 공간 좌표 검색 등 특수 목적
- **MEMORY**: 내부 임시 테이블 처리용

### 📌 MySQL 8.0 이후
- **모든 역할을 InnoDB가 담당**  




# 4.3 MyISAM 스토리지 엔진 아키텍처

## 🔹 키 캐시 

**InnoDB의 버퍼 풀과 유사하지만 인덱스에만 적용**

- 디스크 쓰기 작업에 대해 **버퍼링 역할 수행**
- **히트율 계산 공식**:  
  `100 - (Key_reads / Key_read_requests * 100)`
- 📌 히트율 **99% 이상 유지 권장**
- 제한값 이상 키 캐시를 할당하고 싶다면 **별도의 키 캐시 추가 설정**
- 추가 캐시는 **특정 인덱스에 사용되도록 지정 필요**


## 🔹 운영체제 캐시 

MyISAM **데이터 파일**의 읽기/쓰기 작업은 운영체제의 캐시를 이용!

- 인덱스는 키 캐시로, **데이터는 운영체제의 파일 시스템 캐시**로 처리
- 운영체제 캐시는 **사용 가능한 여유 메모리 기반**으로 동작
- ⚠️ 메모리 부족 시 **데이터 캐시 불가**


## 🔹 프라이머리 키

MyISAM은 **INSERT 순서대로 레코드를 저장**하며,  
**프라이머리 키에 의한 클러스터링은 지원하지 않음**.

- 각 레코드는 **ROWID(물리적 주소값)** 를 가짐

### 🛠️ 고정 길이 ROWID

- `MAX_ROWS` 옵션 사용 시  
  → **4바이트 정수형 ROWID** 사용

### 🛠️ 가변 길이 ROWID

- `MAX_ROWS` 옵션 미사용 시  
  → `myisam_data_pointer_size` 설정에 따라 **기본 7바이트** 사용
  - **첫 바이트**: ROWID 길이  
  - **이후 바이트**: 실제 주소값




# 4.4 MySQL 로그 파일

1. **에러 로그 파일**

- MySQL 시작하는 과정과 관련된 정보성 및 에러 메시지
  → 변수명/값 확인
- 마지막으로 종료할 때 비정상적으로 종료된 경우 나타나는 InnoDB의 트랜잭션 복구 메시지
  → 데이터 정리/복원
- 쿼리 처리 도중에 발생하는 문제에 대한 에러 메시지
- 비정상적으로 종료된 커넥션 메시지
  → 다량 발생 시 커넥션 종료 방식 검토 필요
- InnoDB의 모니터링 또는 상태 조회 명령의 결과 메시지
  → 사용 후 반드시 **모니터링 비활성화**
- MySQL의 종료 메시지
  → 종료 이유 기록

2. **제너럴 쿼리 로그 파일**

서버에 전달된 **모든 쿼리 요청을 기록**

- MySQL이 쿼리 요청을 받으면 바로 기록
  → 실행 중 에러 발생해도 일단 기록
- `log_output` 옵션으로 파일, 테이블 중 저장 형식 선택

3. **슬로우 쿼리 로그**

**실행 시간이 오래 걸리는 쿼리**를 추적할 수 있도록 기록

- long_query_time 이상 소요된 쿼리만 기록
  → 반드시 **정상적으로 실행 완료**되어야 기록
- `log_output` 옵션으로 파일, 테이블 중 저장 형식 선택
- `pt-query-digest` 스크립트로 분석하면 다음과 같이 정리됨:

  1. 슬로우 쿼리 통계
  2. 실행 빈도 및 누적 실행 시간 기준 랭킹
  3. 쿼리별 실행 횟수 및 누적 시간 상세 정보
