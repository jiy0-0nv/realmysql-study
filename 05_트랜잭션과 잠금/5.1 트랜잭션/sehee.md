# 5.1 트랜잭션

## 📌 정의  
트랜잭션은 논리적인 작업 셋이 **모두 적용되거나 아무것도 적용되지 않도록 보장**하는 기능

## ⚙️ 스토리지 엔진별 지원
- `InnoDB` : 트랜잭션 **지원**
- `MyISAM`, `MEMORY` : 트랜잭션 **미지원**
  - → 쿼리 실패 시 **부분 업데이트** 발생
  - → 재처리 작업 필요 (남은 레코드 수동 삭제 등)

## 💡 중요성  
트랜잭션은 애플리케이션에서 **오류 처리 부담을 줄여주는 핵심 기능**

## ⚠️ 주의사항
- 트랜잭션 **범위는 최소화**하는 것이 좋음
- **네트워크 작업은 트랜잭션 외부에서** 처리해야 안전
- 잘못 사용하면 **서버가 위험한 상태에 빠질 수 있음**

---

# 5.2 MySQL 엔진의 잠금

## 🔒 글로벌 락

- `FLUSH TABLES WITH READ LOCK`  
  → **MySQL 서버 전체**에 영향을 주는 가장 넓은 범위의 락  
  → 백업 등 **일관된 상태 확보**를 위해 사용됨  

- `LOCK INSTANCE FOR BACKUP` (MySQL 8.0~)  
  → **일반 데이터 변경은 허용**, **스키마/사용자 변경은 불가**  
  → 주로 **레플리카 서버**에서 백업 시 사용  
  → 백업 중 구조 변경을 방지하기 위해 도입됨


## 🔒 테이블 락

### 명시적 테이블 락
- 명령어: `LOCK TABLES table_name [READ | WRITE]`
- 해제: `UNLOCK TABLES`
- `InnoDB`에도 사용 가능하나, **온라인 작업에 큰 영향** → **거의 사용되지 않음**

### 묵시적 테이블 락
- `MyISAM`, `MEMORY` 테이블: 데이터 변경 시 **자동 발생**, 쿼리 종료 시 **자동 해제**
- `InnoDB`: 기본적으로 **레코드 기반 잠금** 사용 → **스키마 변경 시에만 적용**


## 🔒 네임드 락

- 함수: `GET_LOCK('lock_name', timeout)`  
- **임의 문자열 기반**의 사용자 정의 잠금  
- 잘 쓰이지 않지만,
  - **다중 클라이언트 동기화**
  - **복잡한 조건의 트랜잭션 제어** 시 유용  
- MySQL 8.0부터는 **중첩 잠금도 지원**


## 🔒 메타데이터 락

- **자동 획득되는 락**으로, 테이블의 이름이나 구조 변경 시 사용됨  
  예) `RENAME TABLE` → 원래 이름과 새 이름 **동시에 잠금**

- **InnoDB 트랜잭션과 함께 활용 예시**  
  1. 새로운 테이블 생성  
  2. 기존 테이블의 데이터를 `id` 기준으로 **멀티스레드 복사**  
  3. 나머지 데이터는 트랜잭션 + 테이블 락 + `RENAME TABLE`로 처리  
  4. 결과적으로 **서비스 중단 없이 구조 변경 가능**

---

# 5.3 InnoDB 스토리지 엔진 잠금

InnoDB는 **레코드 기반 잠금 방식**으로 뛰어난 동시성 처리를 제공하며,  
MySQL 명령어만으로는 잠금 상태를 확인하기 어려운 구조

- 내부 잠금 상태는 `INNODB_TRX`, `INNODB_LOCKS`, `INNODB_LOCK_WAITS` 테이블을 조인해 확인 가능  
  → 어떤 트랜잭션이 어떤 잠금을 기다리고 있고, 해당 잠금을 누가 가지고 있는지 확인 가능  
  → **장시간 잠금 클라이언트를 종료하는 등 트러블슈팅 가능**
- `Performance Schema`를 활용한 잠금 모니터링도 가능


## 🔹 InnoDB 스토리지 엔진의 잠금 특징

- **레코드 기반 잠금** 제공
- **잠금 정보가 작게 관리**되어 테이블 락이나 페이지 락으로 격상되지 않음
- **레코드 간 간격도 잠금 가능 (갭 락)**

### 🔐 레코드 락
- **레코드 자체가 아닌 인덱스 레코드**를 잠금
- 인덱스가 없어도 내부적으로 **클러스터 인덱스 자동 생성**하여 잠금 수행
- **Primary Key 또는 Unique Index** 기반 변경 시 **레코드만 잠금**, 갭은 제외

### 🔐 갭 락
- **레코드와 인접한 레코드 사이의 간격**만을 잠금
- 목적: **간격 사이에 새로운 레코드 삽입 방지**
- 단독보다는 주로 **넥스트 키 락의 일부**로 사용됨

### 🔐 넥스트 키 락
- **레코드 락 + 갭 락**을 합친 형태
- `innodb_locks_unsafe_for_binlog` 비활성화 시  
  → 검색된 레코드에 **넥스트 키 락 적용**
- 목적: **바이너리 로그 기반 레플리카 서버의 결과 일관성 보장**
- 단점: **데드락 발생 가능성**  
  → 해결: **바이너리 로그 포맷을 ROW로 변경하여 락 최소화**

### 🔐 자동 증가 락 (AUTO_INCREMENT Lock)
- **자동 증가 칼럼이 있는 테이블**에서 동시에 Insert 시  
  → **각 레코드가 순차적인 숫자**를 받도록 **테이블 수준의 락 사용**
- `INSERT`, `REPLACE` 구문에서만 사용
- **트랜잭션과 무관**하며,  
  → **숫자 할당 순간에만 잠금** 후 즉시 해제
- 명시적 제어는 불가 → `innodb_autoinc_lock_mode`로 작동 방식 조정 가능


## 🔹 인덱스와 잠금

InnoDB는 **레코드 자체가 아니라 인덱스의 레코드**를 잠금으로 처리함  
→ 따라서 **변경할 레코드를 찾기 위해 검색한 모든 인덱스 레코드에 잠금이 걸림**

📌 즉, **불필요한 범위를 잠그지 않도록 인덱스 설계가 매우 중요**


## 🔹 레코드 수준의 잠금 확인 및 해제

레코드 수준의 잠금은 **테이블 수준의 잠금보다 훨씬 복잡**

- 각 레코드 단위로 잠금이 걸리기 때문에,  
  → **자주 사용되지 않는 레코드**가 **오랫동안 잠긴 채로 유지**될 수 있음
- 특히 대량의 레코드를 순차 처리할 경우,  
  → **불필요한 잠금 누적** 발생 가능
- **MySQL 5.1부터는** 아래 정보를 통해 **잠금 상태를 조회 가능**